##分布式系统框架设计

###设计目的
    数据库服务器经常会因为“过热”的原因导致数据库服务器，无法提供服务，所以我们需要解决这个
    “热点“问题，而使用分布式结构可以很好的缓解这个问题，但是我们希望能够解决这个问题，而分布
    式有很多不同的结构，适用于不同目的，我们这里选用一致性哈希(consist hashing)来完全解决
    这个问题.
    
###设计理论

    通过一致性哈希我们可以比较均匀的散列数据，一致性哈希最早在1997年被MIT的论文《 Consistent 
    Hashing and Random Trees》中被提到，这个系统也引用了这篇论文的思想，我们还大致翻译了
    这篇论文，结合Redis集群的思想， 我们的整个架构应运而生了。
    
###架构设计

![一致性哈希](./image/一致性哈希.png)

整个空间是一个我们已经定义的一个区间例如0 ~ 2^32-1,这是一个比较大的空间了，如图所示，我们可以将数据库实例A，B，C加入这个环中，我们假设每一个节点是一个桶适用B 来表示，数据适用i来表示，则存在哈希函数族函数F(i,B).会有一族函数来散列。防止被发现哈希函数规律，导致被恶意攻击，然后我们还可以看到虚拟节点VA。后边会介绍虚拟节点。

每次有请求进入哈希环后，经过哈希运算，得出一个在这个哈希环中的位置，如果这个位置没有对应节点则顺时针走向，找到第一个遇到的节点。

###一致性哈希函数
这里需要使用一致性哈希函数，这里哈希函数主要有以下的一些要求：

单调性：
    
        如果已经有一些内容通过哈希函数散列到了相应的桶中，又有新的桶对象加入到系统中。哈希的
        结果应当能够散列数据到新的桶中，而不是散列到以前的桶中，或者其他的桶中。

散列性：

        我们的哈希函数，应当散列尽可能均匀，对于每一个用户来说使用了这个哈希函数都必须观测到同一个
        视图同一变化。
        
负载性：

        在大量的数据面前能够表现优异，聚簇效应较低。
        
哈希方式：

        使用函数族的全域散列方式,我们首先选择我们的一簇哈希函数，这一簇哈希函数应当是等性质的，

> 定理 
> 设h是从全域散列函数簇H中随机挑选的一个散列函数,如果用h将任意的n个哈希函数元素散列到大小为m的散列表T中，则对于任何元素x，与x发生碰撞的元素个数小于散列表的加载因子，如果Cx为在散列表T里与元素x与y相碰撞的元素个数，则E[Cx]< n/m.

> 推论：使用开放寻址和全域散列，每次搜索操作的期望时间都是O(1).

现在我们来构造一簇哈希函数


1.我们假设我们需要m个函数，待分解元素是k.


2.设m为素数，将每个元素数据k,分解为进制为m的数位，即每个数位的取值范围位{1,2....,m-1},
也就是说分解k = < k0,k1,k2,....kr >(0 <= ki < m ).假定有r+1个数位。


3.随机选取一个进制为m ,长度为r+1个数位的数a = < a0,a1,....,ar> 这里每个ai的值都是从集合{0,1,2,,,,,m-1}中随机选取的。


散列函数如下：

![sanlie](./image/CodeCogsEqn.gif)


经证明，此函数确实是全域散列函数簇。


优化：
    
        虽然我们可以使用全域散列，但是还是有风险的，如果我们时运不济，被厄运突袭，我们就没有
        一点办法了，但是仅仅就哈希函数我们已经没有什么优化的余地了，我们应当尽全力保证在
        任何情况下都需要搜索时间不超过O（1）。
        我们可以使用一种类似邻接表的形式存储哈希表。将哈希表分成两个阶段，第一个部分存贮在这
        个位置碰撞元素的个数n，然后在这个位置对应的第二部分我们开辟n^2个空间来存储剩下的元素。
        经过数学证明，这种结构就是完美的散列。
        
不发生碰撞的概率超过1/2.！！！

###虚拟节点的应用

上边提到了虚拟节点的概念，当我们的虚拟节点很少的时候，极有可能出现负载不均衡的情况，可能发生几个节点负载不均衡的情况出现，所以我们需要使用一些虚拟节点，很多虚拟节点映射实际存在的节点，就能在很大程度上实现负载均衡。

![vnode](./image/Vnode.png)


###增删节点

如图所示，当有一个节点被增加，则必然导致数据库C 和 VA之间的数据不命中，我们必须迁移数据库C中新增节点位置到VA 的数据到新增节点中去，这是不可避免的情况，但是通过一致性哈希的方式我们已经将普通哈希的冲突问题尽可能的缩小了，这样的结果我们时可以接受的，一个节点的改变只影响最多它的上一个或者下一个节点的变化，更何况我们每一个数据库其实还是一个主从模型，很难导致一个数据库下线而不能会来的情况出现。
 
###引用论文及资料

[1]《Consistent hashing and random trees》 1997 麻省理工学院
 
 http://dl.acm.org/citation.cfm?id=258660
 
[2]《算法之道》第二版  邹恒明 第11章搜索与散列